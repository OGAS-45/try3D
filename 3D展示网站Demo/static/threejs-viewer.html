<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Mini-Kujiale - 修复CORS问题</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; }
        #model-container { width: 100vw; height: 100vh; }
        .status {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: Arial, sans-serif;
            color: #333;
            z-index: 100;
        }
        .error { color: #dc3545; }
    </style>
</head>
<body>
    <div id="model-container"></div>
    <div class="status">初始化加载器...</div>

    <!-- 使用ES Modules和可靠的CDN -->
    <script type="module">
        // 解决方法1：使用jsDelivr CDN（较少CORS问题）
        import * as THREE from './static/libs/three.module.js';
        
        
        // 注意：Three.js r150+ 后示例文件路径变更为examples/jsm/
        import { OrbitControls } from './static/libs/OrbitControls.js';
        import { FBXLoader } from './static/libs/FBXLoader.js';

        // 场景设置
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        // 相机设置
        const camera = new THREE.PerspectiveCamera(
            75, 
            window.innerWidth / window.innerHeight, 
            0.1, 
            1000
        );
        camera.position.z = 5;

        // 渲染器设置
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('model-container').appendChild(renderer.domElement);

        // 添加灯光
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // 初始化控制器
        let controls;
        try {
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            document.querySelector('.status').textContent = '控制器加载成功，正在加载模型...';
        } catch (e) {
            console.error('OrbitControls初始化失败:', e);
            document.querySelector('.status').textContent = '控制器加载失败: ' + e.message;
            document.querySelector('.status').classList.add('error');
        }

        // 加载FBX模型
        try {
            const loader = new FBXLoader();
            loader.load(
                '/static/models/gym.fbx',
                function(object) {
                    // 调整模型
                    object.scale.set(0.01, 0.01, 0.01);
                    object.position.y = -1;
                    
                    // 处理材质
                    object.traverse(function(child) {
                        if (child.isMesh) {
                            child.material = new THREE.MeshStandardMaterial({
                                color: 0xaaaaaa,
                                roughness: 0.7,
                                metalness: 0.2
                            });
                        }
                    });
                    
                    scene.add(object);
                    document.querySelector('.status').style.display = 'none';
                },
                function(xhr) {
                    const percent = Math.round((xhr.loaded / xhr.total) * 100);
                    document.querySelector('.status').textContent = `模型加载中: ${percent}%`;
                },
                function(error) {
                    console.error('模型加载错误:', error);
                    document.querySelector('.status').textContent = '模型加载失败: 检查文件路径';
                    document.querySelector('.status').classList.add('error');
                }
            );
        } catch (e) {
            console.error('FBXLoader初始化失败:', e);
            document.querySelector('.status').textContent = '加载器初始化失败: ' + e.message;
            document.querySelector('.status').classList.add('error');
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
